###############################################################################################################

Project 3: Reflections
Name: Gretchen Albornoz

I decided to write this reflection as I worked on the project, not after finishing it because I wanted to keep track of every step I took, what I changed, and why I made it. I updated the HTML, CSS, and JavaScript files, and I wrote down my thoughts at the same time, so it feels more like my real process than a summary. I also wanted to make my commits along the way, pushing each update to keep everything the most as organized as possible and also connected with what I was explaining. This way was easier for me to stay clear about what I was doing and why. 

################################################################################################################


The form had the DELETE method, and this method is not supported by html forms; therefore, I changed the DELETE method to POST method, which is recognized by browsers and it also sendsinformation securely through the request body instead of the URL (GET method).

The password field was hidden using the class ".hidden-password", so it was not visible but still present in the page, so this is not really secure. I fixed by adding "type=pasword", that way users can see the password field and their input is marked when typing. I also added the "required" attribute to make sure the password field is not empty.

I added validation rules to each field to prevent empty or nonsense data. The username field now uses 'required', 'minlength', 'maxlength'. Also, I added 'pattern' so it only accepts letters, numbers, and dashes. The password field is now type="password" with required and minlength="8" to make it hidden and strong. The age field uses type="number" with limits from 1 to 120 to avoid unrealistic values. The email field is type="email" and 'required' to ensure a valid format like “name@example.com”. The message field includes 'required' and maxlength="200" 
to keep the text short and meaningful. With these updates, I keep the form safer, cleaner, and also 
more user-friendly.

I have added a 'patern in the email field to check a valid structure and 'maxlength=254' to keep the standard for email addressses. With these improvement I prevent fake, incomplete, or malformed emails and ensure users provide proper email format.

All labels and input names match correctly, so there is no need to change or correct anything here. Labels and input names must match to ensure accurate data submission and proper user accesibility. With the 'for' and 'id' user can focus on the right field, and the name attribute is for the server to recognize values correctly. Placeholders are give users hints about what information they must type in each field; these feature and 'autocomplete' make the form more user friendly. 

All input fields in the form have 'types' to improve validation. For example, 'type=number' is used for the age field to ensure the browser accepts only numeric values, no texts; this way we can avoid data errors and user experience is better.

I also considered using a 'pattern' to block characters like '<' and '>', which are used to create HTML; this action reduce the risk of XSS attacks. Although this project does not have a server side, it seems to me a good practice to start getting used to for future projects, or if I decide to update and implement this one.

I modified the CSS file (styles.css) to ensure that input fields fit inside the form container; this improves the visual user experience.

I used the ':invalid' and ':valid' selectors to give the form a red border (if input do not meet requirements) or green border (if input meet requirements). Then, I modified the ':invalid' selector rules by adding ':not(:Placeholder-shown); this rule prevents fields form showing red borders at the beginning, and only alert users after typing info to prevent and avoid confusion. 

Previously, I had added an event listener to display an alert in the browser when user enter more than 10 words in the textarea field; howerver, it seemed to me a better user experience to see that message directly inside the form. For that reason, I decided to discard the alert and instead, I used a paragraph element (<p></p>) inside the form; here the function changes the <p> text and send a message using 'setCustomValidity()' JavaScript method.

I have added a 'fieldset' and 'legend' to provide better appeareance and structure, and improve accesibility. This way the form is easy to read and understand, and in general, it looks more professional. 

When I submitted the form, I inspected the network and all static files such as CSS, fonts, images, returned a 200 status code, which means they loaded correctly. However, the search request returned a 404 code (Not Found) response. This response happens because there is not backend endpoint here in this project. 
When I was looking at the form request in the Network tab, in the Payload, I realized that all the information I typed, like the username, password, email, and message, could actually be seen in the Payload. That made me think about how, in a real website, this data could be intercepted if it wasn’t protected. In this project it’s local, so it’s not going anywhere, but on a real website the data travels through the internet. If the site used only HTTP, anyone with access to the network could technically see that information. The way to protect it is by using HTTPS, because this is the way to encrypt everything before it leaves the browser, so even if someone tried to read it, they would just see random characters. 

If this project were a live production form, I would add server-side validation, input sanitization. HTTPS encryption, and error loging to protect data beyond client side validation. The main goal is to guarantee the integrity, confidentiality and reliability of data, and also guarantee a friendly user experience, all while we prevent errors and vulnerabilities.

Although my form works well and validates everything in the browser, I know that users can still try skipping those rules if they have malicious intensions. In real projects, it is a good practice to use server-side and client side validations to keep the form functional, user friendly, and safe. 

Even though my form uses client-side validation to prevent empty or invalid inputs, this doesn’t make it completely secure. The browser only controls what happens on the user’s screen, but it can’t stop someone from editing the form data or sending their own custom request directly to the server. For example, a user could use the browser’s DevTools or another tool to change the data before submitting it.

Real web applications also include server-side validation, which happens after the data is received. The backend checks again if the information is valid, safe, and complete before saving or using it. This second layer of protection helps prevent security risks like code injection or XSS attacks, and makes sure no harmful data reaches the database.

To me, this idea reinforces how client and server validation work together. I think it’s important to get used to applying both approaches, even in small projects like this one, because it builds good habits for when working with real users and sensitive information.


✍️ Ethical Integrity Declaration:
I, Gretchen Albornoz, affirm that all work submitted in this case study is my own. I have not used AI tools, AI-generated text, or AI-based writing assistants (such as ChatGPT, Gemini, Grammarly AI, etc.) in the creation of this assignment. I understand that using AI tools for this project violates the spirit of ethical learning and may result in academic consequences.
Signed: GA     Date: 11/8/2025